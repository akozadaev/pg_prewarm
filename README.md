# Пояснение разницы скорости выполнения первого и последующих запросов к БД PostgreSQL

### Каждый, кто работает с PostgreSQL рано или поздно задается вопросом, почему повторный запрос работает быстрее:

**Потому что срабатывает кэширование.**  
И это не одно кэширование, а сразу несколько уровней:

----------

### 1. Кэширование плана выполнения (**Query Plan Cache**)

Первый раз, когда отправляется SQL-запрос, PostgreSQL **анализирует** его:
    
-   Понимает структуру.      
-   Строит оптимальный **план выполнения** (EXPLAIN).
-   Выбирает, какие индексы использовать, как делать JOIN-ы и т.д.
        
Этот план сохраняется в памяти для текущего соединения (иногда глобально, зависит от настроек).
При **повторном запросе** сервер использует уже готовый план, **не пересчитывая его с нуля**. Это экономит много времени.

----------

### 2. Кэширование данных в памяти (**PostgreSQL Buffer Cache**)

Когда таблица, индекс или часть данных читается первый раз, PostgreSQL **загружает страницы** (страницы по 8Кб) **в оперативную память** (shared_buffers).
При последующих выполнениях запроса, если нужные данные уже есть в памяти (в shared_buffers), то **с диска** их читать **НЕ нужно**, данные берутся **мгновенно** из RAM.
Чтение из RAM многократно быстрее, чем с диска.

----------

### 3. Кэширование ОС (**Filesystem Cache**)

Даже если PostgreSQL сама не все выгрузит из shared_buffers (например, в очень загруженной системе), операционная система **держит файлы в кэше** на уровне файловой системы. В таком случае файловая система" при повторном доступе становится почти как RAM.

----------

 ### В качестве обобщения о причинах ускорения повторных запросов
- Кэш плана запроса: повторно использовать уже готовый план выполнения.
- Кэш данных в PostgreSQL: данные считываются не с диска, а из памяти (shared_buffers).
- Кэш данных в операционной системе: файлы/страницы остаются в RAM, быстрее доступ.

### Проверка утверждений

Это можно проверить на только что установленной базе с чистым кэшем, желательно, чтобы данных было достаточно, чтобы оценить разницу скорости выполнения:

```SQL
-- Первый запуск (будет медленно)
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM большая_таблица WHERE условие;
``` 
```SQL
-- Сразу повторный запуск (будет заметно быстрее)
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM большая_таблица WHERE условие;
``` 
**Первый `Execution Time`** будет больше,  **второй** — сильно меньше,  
**и в BUFFERS** будет видно, что чтение идет из `shared hit`, а не `disk read`.

### Что делать, если нет не кэшированной БД?

PostgreSQL есть разные уровни кэша - и очищать их нужно по-разному:

- План выполнения запросов: `DISCARD PLANS`.
- Сессионный кэш (подключение): `DISCARD ALL`.
- Кэш ОС (filesystem cache): специальной командой в Linux (ручное сбрасывание).
- Буферный кэш базы (shared_buffers): нельзя очистить напрямую — только через перезапуск сервера.

Подробнее, с примерами:
1. Очистить только **планы выполнения** (`DISCARD`) - Удаляет все кэшированные планы запроса в текущем соединении.
```SQL
DISCARD PLANS;
```
2. Очистить **буферный кэш** PostgreSQL (shared_buffers) - перезапуск сервера (PostgreSQL **сам** управляет shared_buffers, и **вручную очистить нельзя**).
```bash
sudo systemctl restart postgresql
```
или
```bash
pg_ctl restart
```
3. Очистить **кэш операционной системы (Linux)** (нужны привелегии)

```bash
# Сбросить только pagecache:
sudo sync
echo 1 | sudo tee /proc/sys/vm/drop_caches

# Или полностью (pagecache + dentries + inodes):
sudo sync
echo 3 | sudo tee /proc/sys/vm/drop_caches
```
Для полной очистки в одной команде:
```bash
sudo systemctl restart postgresql
sudo sync
echo 3 | sudo tee /proc/sys/vm/drop_caches
```

### Как "прогреть" базу в PostgreSQL?
Первый способ. С помощью расширения:

PostgreSQL имеет специальное расширение для прогрева кэша: **`pg_prewarm`**.
**Шаги:**

1.  Установить расширение, если оно не установлено ранее (по умолчанию его нет):
```SQL
CREATE EXTENSION IF NOT EXISTS pg_prewarm;
```
2. Прогреть таблицу (это загрузит данные таблицы в **shared_buffers**.):
```SQL
SELECT pg_prewarm('название_таблицы');
```
3. Прогреть индекс:
```SQL
SELECT pg_prewarm('название_индекса');
```


